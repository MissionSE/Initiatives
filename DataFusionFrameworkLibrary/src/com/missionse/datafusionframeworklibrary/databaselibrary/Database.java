package com.missionse.datafusionframeworklibrary.databaselibrary;

/**
 * @Class Database.java
 *
 * <p>This Database module is used by other modules inside the Data Correlation Application.
 * The Database module provides a framework for inserting new Sources into the Database and
 * retreiving stored Sources. 
 * 
 * <p>The Database module takes in Source objects and determines which information belongs in 
 * the proper tables.</p>
 *
 * <p>This module will return return queried information either in the form of an ArrayList
 * of Sources if multiple Sources are to be returned, or a single source if only one Source
 * will be returned to the requesting module.</p>
 *
 * <p>The database class has the ability to create a new Database File, or load an existing
 * database file. (Which was previously generated by this module).</p>
 *
 * @Author - Josh Grochowski (grocho31@students.rowan.edu)
 *
 * @OS - Tested on Windows 7 Professional 32bit, Mac OSX 10.6.4
 *
 * @Requirements:<br />
 * - For this class to function properly, it needs the HSQL Database driver.
 * HSQLDB Version 2.0 is being used in this program. The HSQL driver can be found
 * at http://hsqldb.com.
 *
 */
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public final class Database implements SourceDataAccessor, CompositeDataAccessor {

	Connection conn;
	final boolean debugging;

	/**
	 * <p>This constructor takes in a Database Name which will be used as the base
	 * for a randomly generated database file name to insure a newly created database
	 * will not overwrite an existing one.</p>
	 *
	 * <p>This constructor will create a connection to a new Database using the
	 * HSQLDB driver. The structure of the database will then be added to the
	 * new database. The tables being created are: compositeTrackData, sourceTrackData and SourceType.</p>
	 *
	 * <p>
	 * Each Database Table serves a specific purpose: <br />
	 * <strong>fusedTrackData:</strong> Source Information that is constantly changing.<br />
	 * <strong>Static:</strong> Source Information that will remain the same during
	 * the duration of the program<br />
	 * </p>
	 *
	 * @param dbname - The base of the randomly generated filename.
	 */
	public Database() {
		//Change debugging to true to enable debugging statements throughout
		//the execution of the program. Recommended to turn off before
		//final build of the program.
		debugging = true;
	}

	public void setupDatabase(String dbname) throws Exception {
		//The base Database cannot be null.
		if (dbname == null) {
			throw new Exception("Invalid Filename.");
		}

		//Sets the SQL Driver to HSQLDB.
		try {
			Class.forName("org.hsqldb.jdbc.JDBCDriver");
		} catch (ClassNotFoundException cnf) {
			if (debugging) {
				System.err.println("Err: CNFException");
				System.out.println(cnf);
			}
		}

		if (debugging) {
			System.out.println("HSQLDB Driver Exists.");
		}

		//Creates a Database Connection. Authenticaion is possible, but
		//not implemented by detault. 
		try {
			conn = DriverManager.getConnection("jdbc:hsqldb:"
					+ generateFileName(dbname), "", "");
		} catch (SQLException e) {
			//Couldn't connect to SQL server.

			if (debugging) {
				System.err.println("Err: SQLException");
			}
		}

		if (debugging) {
			System.out.println("DB Name/Connection sucessfully established.");
		}

		/*
		 * Each time a new database is created, it must be pre populated with
		 * the static and fusedTrackData table structures.
		 */
		try {

			/*
			 * The structures created below allow for any field(s) in the table
			 * to be NULL with the exception of the uniqueId. Incoming sources
			 * without a UniqueId are useless to other modules.
			 */
			create("CREATE TABLE compositeTrackData("
					+ "id INTEGER IDENTITY, "
					+ "uniqueId VARCHAR(256) NOT NULL, "
					+ "sourceTrackType VARCHAR(32),"
					+ "threat INTEGER,"
					+ "latitude DOUBLE, "
					+ "longitude DOUBLE, "
					+ "altitude DOUBLE, "
					+ "fuel DOUBLE, "
					+ "speedX DOUBLE, "
					+ "speedY DOUBLE, "
					+ "speedZ DOUBLE, "
					+ "hertz DOUBLE, "
					+ "depthZ DOUBLE, "
					+ "errorX DOUBLE, "
					+ "errorY DOUBLE, "
					+ "errorZ DOUBLE, "
					+ "positionX DOUBLE, "
					+ "positionY DOUBLE, "
					+ "positionZ DOUBLE, "
					+ "trackPlatform VARCHAR(32), "
					+ "trackCategory VARCHAR(32), "
					+ "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);");

			if (debugging) {
				System.out.println("compositeTrackData Table Created Sucessfully.");
			}

			create("CREATE TABLE sourceTrackData("
					+ "id INTEGER IDENTITY, "
					+ "uniqueId VARCHAR(256) NOT NULL, "
					+ "sourceTrackType VARCHAR(32),"
					+ "threat INTEGER,"
					+ "latitude DOUBLE, "
					+ "longitude DOUBLE, "
					+ "altitude DOUBLE, "
					+ "fuel DOUBLE, "
					+ "speedX DOUBLE, "
					+ "speedY DOUBLE, "
					+ "speedZ DOUBLE, "
					+ "hertz DOUBLE, "
					+ "depthZ DOUBLE, "
					+ "errorX DOUBLE, "
					+ "errorY DOUBLE, "
					+ "errorZ DOUBLE, "
					+ "positionX DOUBLE, "
					+ "positionY DOUBLE, "
					+ "positionZ DOUBLE, "
					+ "trackPlatform VARCHAR(32), "
					+ "trackCategory VARCHAR(32), "
					+ "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);");

			if (debugging) {
				System.out.println("sourceTrackData Table Created Sucessfully.");
			}

			create("CREATE TABLE compositeSourceCrossReference("
					+ "id INTEGER IDENTITY, "
					+ "compositeKeyId VARCHAR(256) NOT NULL, "
					+ "sourceKeyId VARCHAR(32), "
					+ "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");

			if (debugging) {
				System.out.println("sourceType Created Sucessfully.");
			}

		} catch (SQLException e) {

			/*
			 * If an error is caught here, something went wrong while creating
			 * the database structure. The most likely cause of the problem is
			 * the proper write permissions have not been applied to the folder.
			 *
			 * Suggestion: Turn on debugging to narrow down where the error
			 * is occuring at.
			 */
			if (debugging) {
				System.err.println(e);
			}
		}   	
	}

	/**
	 * Given a fileName, concatinate the date and time to the
	 * end of the string. This will ensure that no two database files will
	 * have the same name, and no databases will accidently be overwritten.
	 *
	 * If no name is provided, an exception will be thrown.
	 * 
	 * @param fileName - The base filename for the database. 
	 * @return - A string containing the filename concatinated with the data
	 * and time in for format:
	 */
	private String generateFileName(String fileName) {
		if (fileName == null) {
			//Throw exception
		}

		String uniqueFileName = "";

		Timestamp ts = new Timestamp(System.currentTimeMillis());

		uniqueFileName = uniqueFileName.concat(fileName);
		uniqueFileName = uniqueFileName.concat("_");
		uniqueFileName = uniqueFileName.concat(String.valueOf(ts.getTime()));
		uniqueFileName = uniqueFileName.concat(".sql");

		if (debugging) {
			System.out.println("Database Filename: " + uniqueFileName);
		}

		return uniqueFileName;
	}

	/**
	 * This method takes in an already formed SQL statement which will be used
	 * to create a new table in the database. This method will only ever be used
	 * by the constructor when initially populating the database with tables.
	 *
	 * @param expression - The CREATE statement. (For testing, DROP statements
	 * will also be used)
	 * @throws SQLException - Throws an Exception if a connection to the
	 * SQL Database can not be established.
	 */
	private void create(String expression) throws SQLException {
		if (expression == null) {

			if (debugging) {
				System.out.println("The expression in create() is null.");
			}

			//Throw error

			return;
		}

		//when the statement is executed, a status code is returned.
		Statement statement = conn.createStatement();
		int status = statement.executeUpdate(expression);

		//If the status code returned in the previous statement is -1,
		//then something went wrong with the Database.
		if (status == -1) {
			//Throw Exception
			if (debugging) {
				System.err.println("The Database failed to connect. ");
			}
		}
		statement.close();
	}

	/**
	 * This method should be executed right before the program terminates.
	 * It terminates the connection to the database that was established when
	 * the constructor was originally called.
	 *
	 * @throws SQLException if the SQL statement does not correctly execute.
	 */
	public void shutdown() throws SQLException {
		Statement st = conn.createStatement();
		st.execute("SHUTDOWN");
		conn.close();
	}

	/**
	 * This method will query the Database for a unique list of every
	 * UniqueId currently stored in the database. Each UniqueId will be added
	 * to an ArrayList of Strings are returned to the requesting module.
	 *
	 * If this method is called before any entries have been entered into the
	 * database, null will be returned. 
	 *
	 * @return An ArrayList of Strings containing a unique list of every 
	 * UniqueId currently stored in the database, or null if no entires have
	 * added in the Database yet.
	 */
	public List<String> fetchCompositeDataId() throws SQLException {
		//Temporary stoage location for the List of unique Ids.
		List<String> uniqueIds = new ArrayList<String>();

		//The query to be executed. This query will never change, so there
		//is no reason for a PreparedStatement in this situation.
		String query = "SELECT uniqueId FROM compositeTrackData";

		//Create and Execute the Statement. The results are temporary stored
		//in a Resultset.
		Statement statement = conn.createStatement();
		ResultSet result = statement.executeQuery(query);

		//Close the connection to free resources in the Database. 
		statement.close();

		//For every result, add the uniqueId into an ArrayList.
		while (result.next()) {
			uniqueIds.add(result.getString("uniqueId"));
		}

		if (!uniqueIds.isEmpty()) {
			return uniqueIds;
		} else {
			return null;
		}
	}

	public List<String> fetchSourceDataId() throws SQLException {
		//Temporary storage location for the List of unique Ids.
		List<String> uniqueIds = new ArrayList<String>();

		//The query to be executed. This query will never change, so there
		//is no reason for a PreparedStatement in this situation.
		String query = "SELECT uniqueId FROM sourceTrackData";

		//Create and Execute the Statement. The results are temporary stored
		//in a Resultset.
		Statement statement = conn.createStatement();
		ResultSet result = statement.executeQuery(query);

		//Close the connection to free resources in the Database. 
		statement.close();

		//For every result, add the uniqueId into an ArrayList.
		while (result.next()) {
			uniqueIds.add(result.getString("uniqueId"));
		}

		if (!uniqueIds.isEmpty()) {
			return uniqueIds;
		} else {
			return null;
		}
	}


	/////////////////////////////////////////////////////////////////////////////
	//Source Data
	/////////////////////////////////////////////////////////////////////////////	

	/**
	 * Given a Source this method will break up the information within the
	 * module and add it to the SourceTrackData databases.
	 *
	 * If the Source is null, or missing a uniqueId the method is not executed
	 * because a null Source or Source without a uniqueId is useless.
	 *
	 * @param source - Desired Source to add to the database.
	 * @return - Nothing is Returned.
	 * @throws SQLException - Throws an Exception if an error with the SQL
	 * database occurs.
	 */
	public void updateSourceBuilder(SourceDataModel source) throws SQLException {
		//If the Source is null, or doesn't contain a uniqueId,
		//the information is worthless.

		if ((source == null) || (source.getUniqueId() == null)) {
			//throw exception.
			return;
		}
		//Before executing any statements, make sure that the uniqueId doesn't
		//already exist in the database.
		String staticExist = "SELECT * FROM sourceTrackData WHERE uniqueId = ?";
		PreparedStatement staticCheck = conn.prepareCall(staticExist);
		staticCheck.setString(1, source.getUniqueId());
		ResultSet queryResult = staticCheck.executeQuery();

		//Count the number of results, should be either 0 or 1.
		int counter = 0;
		while (queryResult.next()) {
			counter++;
		}

		/*
		 * If the counter is 0, it means that this is the first time this
		 * uniqueId is being inserted into the database. If the number is 1,
		 * it means a row already exists containing the uniqueId.
		 */
		if (counter < 1) {
			//Static Information
			String staticQuery = "INSERT INTO sourceTrackData("
					+ "uniqueId,"
					+ "sourceTrackType,"
					+ "threat,"
					+ "latitude,"
					+ "longitude,"
					+ "altitude,"
					+ "fuel,"
					+ "speedX,"
					+ "speedY, "
					+ "speedZ, "
					+ "hertz,"
					+ "depthZ,"
					+ "errorX,"
					+ "errorY,"
					+ "errorZ,"
					+ "positionX,"
					+ "positionY,"
					+ "positionZ,"
					+ "trackPlatform,"
					+ "trackCategory)"
					+ "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
			PreparedStatement staticStatement = conn.prepareStatement(staticQuery);

			staticStatement.setString(1, source.getUniqueId());
			staticStatement.setString(2, source.getSourceTrackType());
			staticStatement.setDouble(3, source.getThreatLevel());
			staticStatement.setDouble(4, source.getSourceLatitude());
			staticStatement.setDouble(5, source.getSourceLongitude());
			staticStatement.setDouble(6, source.getSourceAltitude());
			staticStatement.setDouble(7, source.getFuel());
			staticStatement.setDouble(8, source.getSpeedY());
			staticStatement.setDouble(9, source.getSpeedY());
			staticStatement.setDouble(10, source.getSpeedZ());
			staticStatement.setDouble(11, source.getUpdateHertz());
			staticStatement.setDouble(12, source.getDepthZ());
			staticStatement.setDouble(13, source.getErrorX());
			staticStatement.setDouble(14, source.getErrorY());
			staticStatement.setDouble(15, source.getErrorZ());
			staticStatement.setDouble(16, source.getPositionLatitude());
			staticStatement.setDouble(17, source.getPositionLongitude());
			staticStatement.setDouble(18, source.getPositionAltitude());
			staticStatement.setString(19, source.getTrackPlatform());
			staticStatement.setString(20, source.getTrackCategory());

			staticStatement.execute();
			staticStatement.close();
		} else {
			//If the uniqueId already exists, update the information
			//accordingly rather then creating a new row with the
			//same uniqueId.

			//sourceTrackData Information
			String dynamicQuery = "UPDATE sourceTrackData SET "
					+ "sourceTrackType=?,"
					+ "threat=?,"
					+ "latitude=?,"
					+ "longitude=?,"
					+ "altitude=?,"
					+ "fuel=?,"
					+ "speedX=?,"
					+ "speedY=?, "
					+ "speedZ=?, "
					+ "hertz=?,"
					+ "depthZ=?,"
					+ "errorX=?,"
					+ "errorY=?,"
					+ "errorZ=?,"
					+ "positionX=?,"
					+ "positionY=?,"
					+ "positionZ=?,"
					+ "trackPlatform=?,"
					+ "trackCategory=?"
					+ "WHERE uniqueId=?";
			PreparedStatement dynamicStatement = conn.prepareStatement(dynamicQuery);

			//dynamicStatement.setString(1, source.getUniqueId());

			/*
			 * Java's interpretation of null and SQL interpretation of NULL are two
			 * entirely different things. Unfortunately, if a Double is marked as
			 * null in Java, SQL will not know what to do with it when attempting
			 * to insert it in an row. It will throw a NullPointerException. The only
			 * way around this to check every individual row field for being null. If
			 * it is, a special setter must be called (built into PreparedStatement)
			 * which will specifically set the column value to SQL NULL.
			 */
			if (source.getSourceTrackType() != null) {
				dynamicStatement.setString(1, source.getSourceTrackType());
			} else {
				dynamicStatement.setNull(1, 8);
			}

			if (source.getThreatLevel() != null) {
				dynamicStatement.setInt(2, source.getThreatLevel());
			} else {
				dynamicStatement.setNull(2, 8);
			}

			if (source.getSourceLatitude() != null) {
				dynamicStatement.setDouble(3, source.getSourceLatitude());
			} else {
				dynamicStatement.setNull(3, 8);
			}

			if (source.getSourceLongitude() != null) {
				dynamicStatement.setDouble(4, source.getSourceLongitude());
			} else {
				dynamicStatement.setNull(4, 8);
			}

			if (source.getSourceAltitude() != null) {
				dynamicStatement.setDouble(5, source.getSourceAltitude());
			} else {
				dynamicStatement.setNull(5, 8);
			}

			if (source.getFuel() != null) {
				dynamicStatement.setDouble(6, source.getFuel());
			} else {
				dynamicStatement.setNull(6, 8);
			}

			if (source.getSpeedX() != null) {
				dynamicStatement.setDouble(7, source.getSpeedX());
			} else {
				dynamicStatement.setNull(7, 8);
			}

			if (source.getSpeedY() != null) {
				dynamicStatement.setDouble(8, source.getSpeedY());
			} else {
				dynamicStatement.setNull(8, 8);
			}

			if (source.getSpeedZ() != null) {
				dynamicStatement.setDouble(9, source.getSpeedZ());
			} else {
				dynamicStatement.setNull(9, 8);
			}

			if (source.getUpdateHertz() != null) {
				dynamicStatement.setDouble(10, source.getUpdateHertz());
			} else {
				dynamicStatement.setNull(10, 8);
			}

			if (source.getDepthZ() != null) {
				dynamicStatement.setDouble(11, source.getDepthZ());
			} else {
				dynamicStatement.setNull(11, 8);
			}

			if (source.getErrorX() != null) {
				dynamicStatement.setDouble(12, source.getErrorX());
			} else {
				dynamicStatement.setNull(12, 8);
			}

			if (source.getErrorY() != null) {
				dynamicStatement.setDouble(13, source.getErrorY());
			} else {
				dynamicStatement.setNull(13, 8);
			}

			if (source.getErrorZ() != null) {
				dynamicStatement.setDouble(14, source.getErrorZ());
			} else {
				dynamicStatement.setNull(14, 8);
			}

			if (source.getPositionLatitude() != null) {
				dynamicStatement.setDouble(15, source.getPositionLatitude());
			} else {
				dynamicStatement.setNull(15, 8);
			}

			if (source.getPositionLongitude() != null) {
				dynamicStatement.setDouble(16, source.getPositionLongitude());
			} else {
				dynamicStatement.setNull(16, 8);
			}

			if (source.getPositionAltitude() != null) {
				dynamicStatement.setDouble(17, source.getPositionAltitude());
			} else {
				dynamicStatement.setNull(17, 8);
			}

			if (source.getTrackPlatform() != null) {
				dynamicStatement.setString(18, source.getTrackPlatform());
			} else {
				dynamicStatement.setNull(18, 8);
			}

			if (source.getTrackCategory() != null) {
				dynamicStatement.setString(19, source.getTrackCategory());
			} else {
				dynamicStatement.setNull(19, 8);
			}

			dynamicStatement.setString(20, source.getUniqueId());
			/*
			 * After execution of the statement, the connection should be closed
			 * to free up resources in the databse.
			 */
			dynamicStatement.execute();
			dynamicStatement.close();
		}
	}

	/*    private SourceDataModel getStaticInformation(String uniqueId) throws SQLException {

        String staticQuery;

        staticQuery = "SELECT * FROM staticInfo WHERE uniqueId = (?)";

        PreparedStatement staticStatement = conn.prepareCall(staticQuery);
        staticStatement.setString(1, uniqueId);
        ResultSet staticResults = staticStatement.executeQuery();

	 *//**
	 * Create a new Source object and add the Static information to it.
	 * This will be used while iterating through the fusedTrackData information
	 * later. It is more efficent to create a Object containing the Static
	 * information rather than iterating through a ResultSet X amount of
	 * times.
	 *//*
        SourceDataModel staticSource = new SourceDataModel(uniqueId);

        //Source staticSource = new Source();
        while (staticResults.next()) {
            //Save the Static Information in a source.
            staticSource.setUniqueId(uniqueId);
            staticSource.setTrackPlatform(staticResults.getString("trackPlatform"));
            staticSource.setTrackCategory(staticResults.getString("trackCategory"));

        }

        return staticSource;
    }*/

	private Timestamp getFirstTimeEntryInSourceDatabase(String uniqueId) throws SQLException {
		String query = "SELECT dateCreated FROM sourceTrackData WHERE uniqueId = ?";
		PreparedStatement statement = conn.prepareStatement(query);
		statement.setString(1, uniqueId);
		ResultSet result = statement.executeQuery();

		//iterate through the fusedTrackData results, create a new source object
		//and all it to the Source array which will be returned to the
		//requesting module.
		while (result.next()) {

			return result.getTimestamp("dateCreated");
		}
		return null;
	}

	/**
	 * This module will return a single source matching a desired time. This module will pad
	 * the desired time request with +/- 2 seconds to increase the probability that a result
	 * will be sucessfully fetched.
	 *
	 * This module will take the query results, and return the first Source object generated
	 * by the ResultSet. If no information is available within that time frame, null will
	 * be returned.
	 *
	 * @param uniqueId - The UniqueId of the desired Source.
	 * @param desiredTime - The desired time for a source to be returned.
	 * @return A single Source matching the desiredTime, or null if no Sources exist in the
	 * database matching the desired time.
	 * @throws SQLException Throws an exception if an errors occurs with SQL. 
	 */
	public SourceDataModel querySourceBuilder(String uniqueId, long desiredTime) throws SQLException {
		//TODO, fix other query builder method.

		/*		//Gets the creation date of the first uniqueId
		Timestamp firstEntry = getFirstTimeEntryInSourceDatabase(uniqueId);

		if (firstEntry == null) {
			System.out.println("querySourceBuilder NOT FOUND");
			return null;
		}

		//Grabs the Static Information.
		//SourceDataModel staticSource = getStaticInformation(uniqueId);

		//Given the curent time, create a +/- 2 second range to query the database from. 
		Timestamp startingTimeStamp = new Timestamp(desiredTime + 2000);
		Timestamp endingTimeStamp = new Timestamp(desiredTime - 2000);


		if (startingTimeStamp.before(firstEntry)) {
			startingTimeStamp = firstEntry;
		}*/
		String dynamicQuery = "SELECT * FROM sourceTrackData WHERE uniqueId = ?";
		PreparedStatement statement = conn.prepareStatement(dynamicQuery);
		/*		statement.setTimestamp(1, endingTimeStamp);
		statement.setTimestamp(2, startingTimeStamp);*/
		statement.setString(1, uniqueId);
		ResultSet dynamicResults = statement.executeQuery();

		//iterate through the fusedTrackData results, create a new source object
		//and all it to the Source array which will be returned to the
		//requesting module.
		while (dynamicResults.next()) {
			SourceDataModel temp = new SourceDataModel(
					uniqueId,
					dynamicResults.getString("sourceTrackType"),
					dynamicResults.getString("trackPlatform"),
					dynamicResults.getString("trackCategory"),
					dynamicResults.getInt("threat"),
					dynamicResults.getDouble("speedX"),
					dynamicResults.getDouble("speedY"),
					dynamicResults.getDouble("latitude"),
					dynamicResults.getDouble("longitude"),
					dynamicResults.getDouble("altitude"),
					dynamicResults.getDouble("fuel"),
					dynamicResults.getDouble("errorX"),
					dynamicResults.getDouble("errorY"),
					dynamicResults.getDouble("hertz"),
					dynamicResults.getDouble("depthZ"),
					dynamicResults.getDouble("positionX"),
					dynamicResults.getDouble("positionY"),
					dynamicResults.getDouble("errorZ"),
					dynamicResults.getDouble("positionZ"),
					dynamicResults.getDouble("speedZ"));
			System.out.println("dynamicResults: " + uniqueId);

			return temp;
		}

		//If no results were returned, return null
		return null;
	}

	/**
	 * The method generates an ArrayList of Sources to return to a requesting module.
	 * This method queries the database fetching all information matching a specified
	 * uniqueId, sourceType (Air, Naval, Ground), and a time range. The information
	 * that is returned is converted into a Source object and added to an ArrayList
	 * which is returned to the user after all results returned are added to the List.
	 *
	 * @param sourceType - Type of Source - AirSource, GroundSource, or NavalSource.
	 * @param uniqueId - The UniqueId of the Information needed.
	 * @param fromTime - The earliest time of the desired information.
	 * @return an ArrayList of Sources generated from the queried information in
	 * the database.
	 * @throws SQLException - Throws an exception if the connection to the database
	 * fails.
	 */
	public List<SourceDataModel> querySourceBuilder(String sourceType,
			String uniqueId, long fromTime) throws SQLException {
		//Gets the creation date of the first uniqueId
		Timestamp firstEntry = getFirstTimeEntryInSourceDatabase(uniqueId);

		if (firstEntry == null) {
			//throw error, ID doesnt exist.
		}

		//Fetches the Static Information corresponding with the
		//SourceDataModel staticSource = getStaticInformation(uniqueId);

		/**
		 * Fetch the fusedTrackData Information.
		 */
		Timestamp fromTimeStamp = new Timestamp(fromTime);
		Timestamp currentTimeStamp = new Timestamp(System.currentTimeMillis());

		if (fromTimeStamp.before(firstEntry)) {
			fromTimeStamp = firstEntry;
		}

		String dynamicQuery = "SELECT * FROM sourceTrackData WHERE dateCreated BETWEEN ? AND ? AND uniqueId = ?";
		PreparedStatement statement = conn.prepareStatement(dynamicQuery);
		statement.setTimestamp(1, currentTimeStamp);
		statement.setTimestamp(2, fromTimeStamp);
		statement.setString(3, uniqueId);
		ResultSet dynamicResults = statement.executeQuery();

		List<SourceDataModel> resultArray = new ArrayList<SourceDataModel>();

		//iterate through the fusedTrackData results, create a new source object
		//and all it to the Source array which will be returned to the
		//requesting module.
		while (dynamicResults.next()) {
			SourceDataModel temp = new SourceDataModel(
					uniqueId,
					dynamicResults.getString("sourceTrackType"),
					dynamicResults.getString("trackPlatform"),
					dynamicResults.getString("trackCategory"),
					dynamicResults.getInt("threat"),
					dynamicResults.getDouble("speedX"),
					dynamicResults.getDouble("speedY"),
					dynamicResults.getDouble("latitude"),
					dynamicResults.getDouble("longitude"),
					dynamicResults.getDouble("altitude"),
					dynamicResults.getDouble("fuel"),
					dynamicResults.getDouble("errorX"),
					dynamicResults.getDouble("errorY"),
					dynamicResults.getDouble("hertz"),
					dynamicResults.getDouble("depthZ"),
					dynamicResults.getDouble("positionX"),
					dynamicResults.getDouble("positionY"),
					dynamicResults.getDouble("errorZ"),
					dynamicResults.getDouble("positionZ"),
					dynamicResults.getDouble("speedZ"));

			resultArray.add(temp);
		}
		return resultArray;
	}

	/////////////////////////////////////////////////////////////////////////////
	//Composite Data
	/////////////////////////////////////////////////////////////////////////////	

	/**
	 * Given a Composite track this method will break up the information within the
	 * module and add it to compositeTrackData record.
	 *
	 * If the Source is null, or missing a uniqueId the method is not executed
	 * because a null Source or Source without a uniqueId is useless.
	 *
	 * @param source - Desired Source to add to the database.
	 * @return - Nothing is Returned.
	 * @throws SQLException - Throws an Exception if an error with the SQL
	 * database occurs.
	 */
	public void updateCompositeBuilder(SourceDataModel source) throws SQLException {
		//If the Source is null, or doesn't contain a uniqueId,
		//the information is worthless.

		if ((source == null) || (source.getUniqueId() == null)) {
			//throw exception.
		}
		System.out.println("updateCompositeBuilder "+source.getUniqueId());

		//Before executing any statements, make sure that the uniqueId doesn't
		//already exist in the database.
		String staticExist = "SELECT * FROM compositeTrackData WHERE uniqueId = ?";
		PreparedStatement staticCheck = conn.prepareCall(staticExist);
		staticCheck.setString(1, source.getUniqueId());
		ResultSet queryResult = staticCheck.executeQuery();

		//Count the number of results, should be either 0 or 1.
		int counter = 0;
		while (queryResult.next()) {
			counter++;
		}


		/*
		 * If the counter is 0, it means that this is the first time this
		 * uniqueId is being inserted into the database. If the number is 1,
		 * it means a row already exists containing the uniqueId.
		 */
		if (counter < 1) {
			//Static Information
			String staticQuery = "INSERT INTO compositeTrackData("
					+ "uniqueId,"
					+ "sourceTrackType,"
					+ "threat,"
					+ "latitude,"
					+ "longitude,"
					+ "altitude,"
					+ "fuel,"
					+ "speedX,"
					+ "speedY, "
					+ "speedZ, "
					+ "hertz,"
					+ "depthZ,"
					+ "errorX,"
					+ "errorY,"
					+ "errorZ,"
					+ "positionX,"
					+ "positionY,"
					+ "positionZ,"
					+ "trackPlatform,"
					+ "trackCategory)"
					+ "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
			PreparedStatement staticStatement = conn.prepareStatement(staticQuery);

			staticStatement.setString(1, source.getUniqueId());
			staticStatement.setString(2, source.getSourceTrackType());
			staticStatement.setDouble(3, source.getThreatLevel());
			staticStatement.setDouble(4, source.getSourceLatitude());
			staticStatement.setDouble(5, source.getSourceLongitude());
			staticStatement.setDouble(6, source.getSourceAltitude());
			staticStatement.setDouble(7, source.getFuel());
			staticStatement.setDouble(8, source.getSpeedY());
			staticStatement.setDouble(9, source.getSpeedY());
			staticStatement.setDouble(10, source.getSpeedZ());
			staticStatement.setDouble(11, source.getUpdateHertz());
			staticStatement.setDouble(12, source.getDepthZ());
			staticStatement.setDouble(13, source.getErrorX());
			staticStatement.setDouble(14, source.getErrorY());
			staticStatement.setDouble(15, source.getErrorZ());
			staticStatement.setDouble(16, source.getPositionLatitude());
			staticStatement.setDouble(17, source.getPositionLongitude());
			staticStatement.setDouble(18, source.getPositionAltitude());
			staticStatement.setString(19, source.getTrackPlatform());
			staticStatement.setString(20, source.getTrackCategory());

			staticStatement.execute();
			staticStatement.close();			
		} else {

			//fusedTrackData Information
			String dynamicQuery = "UPDATE compositeTrackData SET "
					+ "sourceTrackType=?,"
					+ "threat=?,"
					+ "latitude=?,"
					+ "longitude=?,"
					+ "altitude=?,"
					+ "fuel=?,"
					+ "speedX=?,"
					+ "speedY=?, "
					+ "speedZ=?, "
					+ "hertz=?,"
					+ "depthZ=?,"
					+ "errorX=?,"
					+ "errorY=?,"
					+ "errorZ=?,"
					+ "positionX=?,"
					+ "positionY=?,"
					+ "positionZ=?,"
					+ "trackPlatform=?,"
					+ "trackCategory=?"
					+ "WHERE uniqueId=?";
			PreparedStatement dynamicStatement = conn.prepareStatement(dynamicQuery);

			/*
			 * Java's interpretation of null and SQL interpretation of NULL are two
			 * entirely different things. Unfortunately, if a Double is marked as
			 * null in Java, SQL will not know what to do with it when attempting
			 * to insert it in an row. It will throw a NullPointerException. The only
			 * way around this to check every individual row field for being null. If
			 * it is, a special setter must be called (built into PreparedStatement)
			 * which will specifically set the column value to SQL NULL.
			 */
			if (source.getSourceTrackType() != null) {
				dynamicStatement.setString(1, source.getSourceTrackType());
			} else {
				dynamicStatement.setNull(1, 8);
			}

			if (source.getThreatLevel() != null) {
				dynamicStatement.setLong(2, source.getThreatLevel());
			} else {
				dynamicStatement.setNull(2, 8);
			}

			if (source.getSourceLatitude() != null) {
				dynamicStatement.setDouble(3, source.getSourceLatitude());
			} else {
				dynamicStatement.setNull(3, 8);
			}

			if (source.getSourceLatitude() != null) {
				dynamicStatement.setDouble(4, source.getSourceLatitude());
			} else {
				dynamicStatement.setNull(4, 8);
			}

			if (source.getSourceAltitude() != null) {
				dynamicStatement.setDouble(5, source.getSourceAltitude());
			} else {
				dynamicStatement.setNull(5, 8);
			}

			if (source.getFuel() != null) {
				dynamicStatement.setDouble(6, source.getFuel());
			} else {
				dynamicStatement.setNull(6, 8);
			}

			if (source.getSpeedX() != null) {
				dynamicStatement.setDouble(7, source.getSpeedX());
			} else {
				dynamicStatement.setNull(7, 8);
			}

			if (source.getSpeedY() != null) {
				dynamicStatement.setDouble(8, source.getSpeedY());
			} else {
				dynamicStatement.setNull(8, 8);
			}

			if (source.getSpeedZ() != null) {
				dynamicStatement.setDouble(9, source.getSpeedZ());
			} else {
				dynamicStatement.setNull(9, 8);
			}

			if (source.getUpdateHertz() != null) {
				dynamicStatement.setDouble(10, source.getUpdateHertz());
			} else {
				dynamicStatement.setNull(10, 8);
			}

			if (source.getDepthZ() != null) {
				dynamicStatement.setDouble(11, source.getDepthZ());
			} else {
				dynamicStatement.setNull(11, 8);
			}

			if (source.getErrorX() != null) {
				dynamicStatement.setDouble(12, source.getErrorX());
			} else {
				dynamicStatement.setNull(12, 8);
			}

			if (source.getErrorY() != null) {
				dynamicStatement.setDouble(13, source.getErrorY());
			} else {
				dynamicStatement.setNull(13, 8);
			}

			if (source.getErrorZ() != null) {
				dynamicStatement.setDouble(14, source.getErrorZ());
			} else {
				dynamicStatement.setNull(14, 8);
			}

			if (source.getPositionLatitude() != null) {
				dynamicStatement.setDouble(15, source.getPositionLatitude());
			} else {
				dynamicStatement.setNull(15, 8);
			}

			if (source.getPositionLongitude() != null) {
				dynamicStatement.setDouble(16, source.getPositionLongitude());
			} else {
				dynamicStatement.setNull(16, 8);
			}

			if (source.getPositionAltitude() != null) {
				dynamicStatement.setDouble(17, source.getPositionAltitude());
			} else {
				dynamicStatement.setNull(17, 8);
			}

			if (source.getTrackPlatform() != null) {
				dynamicStatement.setString(18, source.getTrackPlatform());
			} else {
				dynamicStatement.setNull(18, 8);
			}

			if (source.getTrackCategory() != null) {
				dynamicStatement.setString(19, source.getTrackCategory());
			} else {
				dynamicStatement.setNull(19, 8);
			}

			dynamicStatement.setString(20, source.getUniqueId());

			/*
			 * After execution of the statement, the connection should be closed
			 * to free up resources in the databse.
			 */
			dynamicStatement.execute();
			dynamicStatement.close();
		}
	}

	private Timestamp getFirstTimeEntryInCompositeDatabase(String uniqueId) throws SQLException {
		String query = "SELECT dateCreated FROM compositeTrackData WHERE uniqueId = ?";
		PreparedStatement statement = conn.prepareStatement(query);
		statement.setString(1, uniqueId);
		ResultSet result = statement.executeQuery();

		//iterate through the fusedTrackData results, create a new source object
		//and all it to the Source array which will be returned to the
		//requesting module.
		while (result.next()) {

			return result.getTimestamp("dateCreated");
		}

		return null;
	}

	/**
	 * This module will return a single source matching a desired time. This module will pad
	 * the desired time request with +/- 2 seconds to increase the probability that a result
	 * will be sucessfully fetched.
	 *
	 * This module will take the query results, and return the first Source object generated
	 * by the ResultSet. If no information is available within that time frame, null will
	 * be returned.
	 *
	 * @param uniqueId - The UniqueId of the desired Source.
	 * @param desiredTime - The desired time for a source to be returned.
	 * @return A single Source matching the desiredTime, or null if no Sources exist in the
	 * database matching the desired time.
	 * @throws SQLException Throws an exception if an errors occurs with SQL. 
	 */
	public SourceDataModel queryCompositeBuilder(String uniqueId, long desiredTime) throws SQLException {
		//TODO, fix other query builder method.

		//Gets the creation date of the first uniqueId
		Timestamp firstEntry = getFirstTimeEntryInCompositeDatabase(uniqueId);

		if (firstEntry == null) {
			//throw error, ID doesnt exist. 
		}

		//Grabs the Static Information.
		//SourceDataModel staticSource = getStaticInformation(uniqueId);

		//Given the curent time, create a +/- 2 second range to query the database from. 
		Timestamp startingTimeStamp = new Timestamp(desiredTime + 2000);
		Timestamp endingTimeStamp = new Timestamp(desiredTime - 2000);


		if (startingTimeStamp.before(firstEntry)) {
			startingTimeStamp = firstEntry;
		}
		String dynamicQuery = "SELECT * FROM compositeTrackData WHERE (dateCreated BETWEEN ? AND ?) AND (uniqueId = ?)";
		PreparedStatement statement = conn.prepareStatement(dynamicQuery);
		statement.setTimestamp(1, endingTimeStamp);
		statement.setTimestamp(2, startingTimeStamp);
		statement.setString(3, uniqueId);
		ResultSet dynamicResults = statement.executeQuery();


		//iterate through the fusedTrackData results, create a new source object
		//and all it to the Source array which will be returned to the
		//requesting module.
		while (dynamicResults.next()) {

			SourceDataModel temp = new SourceDataModel(
					uniqueId,
					dynamicResults.getString("sourceTrackType"),
					dynamicResults.getString("trackPlatform"),
					dynamicResults.getString("trackCategory"),
					dynamicResults.getInt("threat"),
					dynamicResults.getDouble("speedX"),
					dynamicResults.getDouble("speedY"),
					dynamicResults.getDouble("latitude"),
					dynamicResults.getDouble("longitude"),
					dynamicResults.getDouble("altitude"),
					dynamicResults.getDouble("fuel"),
					dynamicResults.getDouble("errorX"),
					dynamicResults.getDouble("errorY"),
					dynamicResults.getDouble("hertz"),
					dynamicResults.getDouble("depthZ"),
					dynamicResults.getDouble("positionX"),
					dynamicResults.getDouble("positionY"),
					dynamicResults.getDouble("errorZ"),
					dynamicResults.getDouble("positionZ"),
					dynamicResults.getDouble("speedZ"));

			return temp;
		}

		//If no results were returned, return null
		return null;
	}

	/**
	 * The method generates an ArrayList of Sources to return to a requesting module.
	 * This method queries the database fetching all information matching a specified
	 * uniqueId, sourceType (Air, Naval, Ground), and a time range. The information
	 * that is returned is converted into a Source object and added to an ArrayList
	 * which is returned to the user after all results returned are added to the List.
	 *
	 * @param sourceType - Type of Source - AirSource, GroundSource, or NavalSource.
	 * @param uniqueId - The UniqueId of the Information needed.
	 * @param fromTime - The earliest time of the desired information.
	 * @return an ArrayList of Sources generated from the queried information in
	 * the database.
	 * @throws SQLException - Throws an exception if the connection to the database
	 * fails.
	 */
	public List<SourceDataModel> queryCompositeBuilder(String sourceType,
			String uniqueId, long fromTime) throws SQLException {

		/*		//Gets the creation date of the first uniqueId
		Timestamp firstEntry = getFirstTimeEntryInCompositeDatabase(uniqueId);

		if (firstEntry == null) {
			//throw error, ID doesnt exist.
		}

		//Fetches the Static Information corresponding with the
		//SourceDataModel staticSource = getStaticInformation(uniqueId);

		 *//**
		 * Fetch the fusedTrackData Information.
		 *//*
		Timestamp fromTimeStamp = new Timestamp(fromTime);
		Timestamp currentTimeStamp = new Timestamp(System.currentTimeMillis());

		if (fromTimeStamp.before(firstEntry)) {
			fromTimeStamp = firstEntry;
		}
		  */
		String dynamicQuery = "SELECT * FROM compositeTrackData";
		PreparedStatement statement = conn.prepareStatement(dynamicQuery);
		/*		statement.setTimestamp(1, currentTimeStamp);
		statement.setTimestamp(2, fromTimeStamp);
		statement.setString(1, uniqueId);
		 */		ResultSet dynamicResults = statement.executeQuery();


		 List<SourceDataModel> resultArray = new ArrayList<SourceDataModel>();

		 //iterate through the fusedTrackData results, create a new source object
		 //and all it to the Source array which will be returned to the
		 //requesting module.
		 while (dynamicResults.next()) {

			 SourceDataModel temp = new SourceDataModel(
					 dynamicResults.getString("uniqueId"),
					 dynamicResults.getString("sourceTrackType"),
					 dynamicResults.getString("trackPlatform"),
					 dynamicResults.getString("trackCategory"),
					 dynamicResults.getInt("threat"),
					 dynamicResults.getDouble("speedX"),
					 dynamicResults.getDouble("speedY"),
					 dynamicResults.getDouble("latitude"),
					 dynamicResults.getDouble("longitude"),
					 dynamicResults.getDouble("altitude"),
					 dynamicResults.getDouble("fuel"),
					 dynamicResults.getDouble("errorX"),
					 dynamicResults.getDouble("errorY"),
					 dynamicResults.getDouble("hertz"),
					 dynamicResults.getDouble("depthZ"),
					 dynamicResults.getDouble("positionX"),
					 dynamicResults.getDouble("positionY"),
					 dynamicResults.getDouble("errorZ"),
					 dynamicResults.getDouble("positionZ"),
					 dynamicResults.getDouble("speedZ"));

			 resultArray.add(temp);

		 }
		 return resultArray;
	}

	/////////////////////////////////////////////////////////////////////////////
	//Composite Source CrossReference
	/////////////////////////////////////////////////////////////////////////////	

	/**
	 * Given a Composite track key and source track key, this will pair them up.
	 *
	 *
	 * @param compositeID - Composite track.
	 * @param sourceID - Composite track.
	 * @return - Nothing is Returned.
	 * @throws SQLException - Throws an Exception if an error with the SQL
	 * database occurs.
	 */
	public void updateCompositeSourceCrossReference(String compositeId, String sourceId) throws SQLException {
		String staticQuery = "INSERT INTO compositeSourceCrossReference("
				+ "compositeKeyId,"
				+ "sourceKeyId,"
				+ "VALUES(?,?)";
		PreparedStatement staticStatement = conn.prepareStatement(staticQuery);

		staticStatement.setString(1, compositeId);
		staticStatement.setString(2, sourceId);

		staticStatement.execute();
		staticStatement.close();			
	}


	/**
	 * Given a Composite track key this method returns a list of sources.
	 *
	 *
	 * @param compositeID - Composite track.
	 * @return List of sources.
	 * @throws SQLException - Throws an Exception if an error with the SQL
	 * database occurs.
	 */
	public List<String> fetchSourcesForComposite(String compositeId) throws SQLException {
		//Temporary storage location for the List of unique Ids.
		List<String> crossReference = new ArrayList<String>();

		String query = "SELECT * FROM compositeSourceCrossReference WHERE compositeKeyId = ?";
		PreparedStatement statement = conn.prepareStatement(query);
		statement.setString(1, compositeId);
		ResultSet result = statement.executeQuery();		

		//Close the connection to free resources in the Database. 
		statement.close();

		//For every result, add the uniqueId into an ArrayList.
		while (result.next()) {
			if (!crossReference.contains(result.getString("sourceKeyId"))) {
				crossReference.add(result.getString("sourceKeyId"));
			}
		}

		if (!crossReference.isEmpty()) {
			return crossReference;
		} else {
			return null;
		}			
	}

}
