package datacorrelation;

/**
 * @Class Database.java
 *
 * <p>This Database module is used by other modules inside the Data Correlation Application.
 * The Database module provides a framework for inserting new Sources into the Database and
 * retreiving stored Sources. 
 * 
 * <p>The Database module takes in Source objects and determines which information belongs in 
 * the proper tables.</p>
 *
 * <p>This module will return return queried information either in the form of an ArrayList
 * of Sources if multiple Sources are to be returned, or a single source if only one Source
 * will be returned to the requesting module.</p>
 *
 * <p>The database class has the ability to create a new Database File, or load an existing
 * database file. (Which was previously generated by this module).</p>
 *
 * @Author - Josh Grochowski (grocho31@students.rowan.edu)
 *
 * @OS - Tested on Windows 7 Professional 32bit, Mac OSX 10.6.4
 *
 * @Requirements:<br />
 * - For this class to function properly, it needs the HSQL Database driver.
 * HSQLDB Version 2.0 is being used in this program. The HSQL driver can be found
 * at http://hsqldb.com.
 *
 */
import java.sql.*;
import java.util.ArrayList;

public final class Database {

    Connection conn;
    final boolean debugging;

    /**
     * <p>This constructor takes in a Database Name which will be used as the base
     * for a randomly generated database file name to insure a newly created database
     * will not overwrite an existing one.</p>
     *
     * <p>This constructor will create a connection to a new Database using the
     * HSQLDB driver. The structure of the database will then be added to the
     * new database. The tables being created are: Dynamic, Static and Categories.</p>
     *
     * <p>
     * Each Database Table serves a specific purpose: <br />
     * <strong>Dynamic:</strong> Source Information that is constantly changing.<br />
     * <strong>Static:</strong> Source Information that will remain the same during
     * the duration of the program<br />
     * </p>
     *
     * @param dbname - The base of the randomly generated filename.
     */
    public Database(String dbname) throws Exception {

        //The base Database cannot be null.
        if (dbname == null) {
            throw new Exception("Invalid Filename.");
        }

        //Change debugging to true to enable debugging statements throughout
        //the execution of the program. Recommended to turn off before
        //final build of the program.
        debugging = true;

        //Sets the SQL Driver to HSQLDB.
        try {
            Class.forName("org.hsqldb.jdbc.JDBCDriver");
        } catch (ClassNotFoundException cnf) {
            if (debugging) {
                System.err.println("Err: CNFException");
                System.out.println(cnf);
            }
        }

        if (debugging) {
            System.out.println("HSQLDB Driver Exists.");
        }

        //Creates a Database Connection. Authenticaion is possible, but
        //not implemented by detault. 
        try {
            conn = DriverManager.getConnection("jdbc:hsqldb:"
                    + generateFileName(dbname), "", "");
        } catch (SQLException e) {
            //Couldn't connect to SQL server.

            if (debugging) {
                System.err.println("Err: SQLException");
            }
        }

        if (debugging) {
            System.out.println("DB Name/Connection sucessfully established.");
        }

        /*
         * Each time a new database is created, it must be pre populated with
         * the static and dynamic table structures.
         */
        try {

            /*
             * The structures created below allow for any field(s) in the table
             * to be NULL with the exception of the uniqueId. Incoming sources
             * without a UniqueId are useless to other modules.
             */
            create("CREATE TABLE S1dynamic("
                    + "id INTEGER IDENTITY, "
                    + "uniqueId VARCHAR(256) NOT NULL, "
                    + "threat INTEGER,"
                    + "latitude DOUBLE, "
                    + "longitude DOUBLE, "
                    + "altitude DOUBLE, "
                    + "fuel DOUBLE, "
                    + "speedX DOUBLE, "
                    + "speedY DOUBLE, "
                    + "speedZ DOUBLE, "
                    + "hertz DOUBLE, "
                    + "depthZ DOUBLE, "
                    + "errorX DOUBLE, "
                    + "errorY DOUBLE, "
                    + "errorZ DOUBLE, "
                    + "positionX DOUBLE, "
                    + "positionY DOUBLE, "
                    + "positionZ DOUBLE, "
                    + "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);");

            if (debugging) {
                System.out.println("S1 Dynamic Table Created Sucessfully.");
            }

            create("CREATE TABLE S1staticInfo("
                    + "id INTEGER IDENTITY, "
                    + "uniqueId VARCHAR(256) NOT NULL, "
                    + "trackType VARCHAR(32), "
                    + "trackPlatform VARCHAR(32), "
                    + "trackCategory VARCHAR(32), "
                    + "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");

            if (debugging) {
                System.out.println("S1 Static Table Created Sucessfully.");
            }

            create("CREATE TABLE S2dynamic("
                    + "id INTEGER IDENTITY, "
                    + "uniqueId VARCHAR(256) NOT NULL, "
                    + "threat INTEGER,"
                    + "latitude DOUBLE, "
                    + "longitude DOUBLE, "
                    + "altitude DOUBLE, "
                    + "fuel DOUBLE, "
                    + "speedX DOUBLE, "
                    + "speedY DOUBLE, "
                    + "speedZ DOUBLE, "
                    + "hertz DOUBLE, "
                    + "depthZ DOUBLE, "
                    + "errorX DOUBLE, "
                    + "errorY DOUBLE, "
                    + "errorZ DOUBLE, "
                    + "positionX DOUBLE, "
                    + "positionY DOUBLE, "
                    + "positionZ DOUBLE, "
                    + "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);");

            if (debugging) {
                System.out.println("S2 Dynamic Table Created Sucessfully.");
            }

            create("CREATE TABLE S2staticInfo("
                    + "id INTEGER IDENTITY, "
                    + "uniqueId VARCHAR(256) NOT NULL, "
                    + "trackType VARCHAR(32), "
                    + "trackPlatform VARCHAR(32), "
                    + "trackCategory VARCHAR(32), "
                    + "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");

            if (debugging) {
                System.out.println("S2 Static Table Created Sucessfully.");
            }

           create("CREATE TABLE systemDynamic("
                    + "id INTEGER IDENTITY, "
                    + "uniqueId VARCHAR(256) NOT NULL, "
                    + "threat INTEGER,"
                    + "latitude DOUBLE, "
                    + "longitude DOUBLE, "
                    + "altitude DOUBLE, "
                    + "fuel DOUBLE, "
                    + "speedX DOUBLE, "
                    + "speedY DOUBLE, "
                    + "speedZ DOUBLE, "
                    + "hertz DOUBLE, "
                    + "depthZ DOUBLE, "
                    + "errorX DOUBLE, "
                    + "errorY DOUBLE, "
                    + "errorZ DOUBLE, "
                    + "positionX DOUBLE, "
                    + "positionY DOUBLE, "
                    + "positionZ DOUBLE, "
                    + "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);");

            if (debugging) {
                System.out.println("System Dynamic Table Created Sucessfully.");
            }
            create("CREATE TABLE systemStaticInfo("
                    + "id INTEGER IDENTITY, "
                    + "uniqueId VARCHAR(256) NOT NULL, "
                    + "sourceType VARCHAR(256) ARRAY[10], "
                    + "trackType VARCHAR(32), "
                    + "trackPlatform VARCHAR(32), "
                    + "trackCategory VARCHAR(32), "
                    + "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");

            if (debugging) {
                System.out.println("System Static Table Created Sucessfully.");
            }

        } catch (SQLException e) {

            /*
             * If an error is caught here, something went wrong while creating
             * the database structure. The most likely cause of the problem is
             * the proper write permissions have not been applied to the folder.
             *
             * Suggestion: Turn on debugging to narrow down where the error
             * is occuring at.
             */
            if (debugging) {
                System.err.println(e);
            }
        }

    }

    /**
     * This method will query the Database for a unique list of every
     * UniqueId currently stored in the database. Each UniqueId will be added
     * to an ArrayList of Strings are returned to the requesting module.
     *
     * If this method is called before any entries have been entered into the
     * database, null will be returned. 
     *
     * @return An ArrayList of Strings containing a unique list of every 
     * UniqueId currently stored in the database, or null if no entires have
     * added in the Database yet.
     */
    public ArrayList<String> fetchUniqueId() throws SQLException {

        //Temporary stoage location for the List of unique Ids.
        ArrayList<String> uniqueIds = new ArrayList<String>();

        //The query to be executed. This query will never change, so there
        //is no reason for a PreparedStatement in this situation.
        String query = "SELECT uniqueId FROM systemStaticInfo";

        //Create and Execute the Statement. The results are temporary stored
        //in a Resultset.
        Statement statement = conn.createStatement();
        ResultSet result = statement.executeQuery(query);

        //Close the connection to free resources in the Database. 
        statement.close();

        //For every result, add the uniqueId into an ArrayList.
        while (result.next()) {
            uniqueIds.add(result.getString("uniqueId"));
        }

        if (!uniqueIds.isEmpty()) {
            return uniqueIds;
        } else {
            return null;
        }
    }

    /**
     * Given a fileName, concatinate the date and time to the
     * end of the string. This will ensure that no two database files will
     * have the same name, and no databases will accidently be overwritten.
     *
     * If no name is provided, an exception will be thrown.
     * 
     * @param fileName - The base filename for the database. 
     * @return - A string containing the filename concatinated with the data
     * and time in for format:
     */
    private String generateFileName(String fileName) {

        if (fileName == null) {
            //Throw exception
        }

        String uniqueFileName = "";

        Timestamp ts = new Timestamp(System.currentTimeMillis());

        uniqueFileName = uniqueFileName.concat(fileName);
        uniqueFileName = uniqueFileName.concat("_");
        uniqueFileName = uniqueFileName.concat(String.valueOf(ts.getTime()));
        uniqueFileName = uniqueFileName.concat(".sql");

        if (debugging) {
            System.out.println("Database Filename: " + uniqueFileName);
        }

        return uniqueFileName;

    }

    /**
     * This method takes in an already formed SQL statement which will be used
     * to create a new table in the database. This method will only ever be used
     * by the constructor when initially populating the database with tables.
     *
     * @param expression - The CREATE statement. (For testing, DROP statements
     * will also be used)
     * @throws SQLException - Throws an Exception if a connection to the
     * SQL Database can not be established.
     */
    private void create(String expression) throws SQLException {

        if (debugging) {
            System.out.println("create");
        }
       if (expression == null) {

            if (debugging) {
                System.out.println("The expression in create() is null.");
            }

            //Throw error

            return;
        }

        //when the statement is executed, a status code is returned.
        Statement statement = conn.createStatement();
        int status = statement.executeUpdate(expression);

        //If the status code returned in the previous statement is -1,
        //then something went wrong with the Database.
        if (status == -1) {
            //Throw Exception
            if (debugging) {
                System.err.println("The Database failed to connect. ");
            }
        }

        statement.close();
    }

    /**
     * This method should be executed right before the program terminates.
     * It terminates the connection to the database that was established when
     * the constructor was originally called.
     *
     * @throws SQLException if the SQL statement does not correctly execute.
     */
    public void shutdown() throws SQLException {
        Statement st = conn.createStatement();
        st.execute("SHUTDOWN");
        conn.close();
    }

    /**
     * Given a Source this method will break up the information within the
     * module and add it to either the Dynamic or Static databases.
     *
     * If the Source is null, or missing a uniqueId the method is not executed
     * because a null Source or Source without a uniqueId is useless.
     *
     * @param source - Desired Source to add to the database.
     * @return - Nothing is Returned.
     * @throws SQLException - Throws an Exception if an error with the SQL
     * database occurs.
     */
    public void updateS1Builder(Source source) throws SQLException {

        //If the Source is null, or doesn't contain a uniqueId,
        //the information is worthless.
        if ((source == null) || (source.getUniqueId() == null)) {
            //throw exception.
        }

        //Before executing any statements, make sure that the uniqueId doesn't
        //already exist in the database.
        String staticExist = "SELECT * FROM S1staticInfo WHERE uniqueId = ?";
        PreparedStatement staticCheck = conn.prepareCall(staticExist);
        staticCheck.setString(1, source.getUniqueId());
        ResultSet queryResult = staticCheck.executeQuery();


        //Count the number of results, should be either 0 or 1.
        int counter = 0;
        while (queryResult.next()) {
            counter++;
        }


        /*
         * If the counter is 0, it means that this is the first time this
         * uniqueId is being inserted into the database. If the number is 1,
         * it means a row already exists containing the uniqueId.
         */
        if (counter < 1) {

            if (debugging) {
                System.out.println("database:updateS1Builder counter 0");
            }
            //Static Information
            String staticQuery = "INSERT INTO S1staticInfo("
                    + "uniqueId,"
                    + "trackType, "
                    + "trackPlatform,"
                    + "trackCategory)"
                    + "VALUES(?,?,?,?)";

            PreparedStatement staticStatement = conn.prepareStatement(staticQuery);

            staticStatement.setString(1, source.getUniqueId());
            staticStatement.setString(2, source.getClass().getName());
            staticStatement.setString(3, source.getTrackPlatform());
            staticStatement.setString(4, source.getTrackCategory());
            staticStatement.execute();
            staticStatement.close();
        } else {

            if (debugging) {
                System.out.println("database:S1updateBuilder counter 1");
            }
            //If the uniqueId already exists, update the information
            //accordingly rather then creating a new row with the
            //same uniqueId.
            String query = "UPDATE S1staticInfo"
                    + " SET trackType=?, "
                    + "trackPlatform=?, "
                    + "trackCategory=?";

            PreparedStatement staticUpdate = conn.prepareStatement(query);

            staticUpdate.setString(1, source.getClass().getName());
            staticUpdate.setString(2, source.getTrackPlatform());
            staticUpdate.setString(3, source.getTrackCategory());

            staticUpdate.execute();
            staticUpdate.close();
        }

        //Dynamic Information
        String dynamicQuery = "INSERT INTO S1dynamic("
                + "uniqueId,"
                + "threat,"
                + "latitude,"
                + "longitude,"
                + "altitude,"
                + "speedX,"
                + "speedY, "
                + "speedZ, "
                + "fuel,"
                + "hertz,"
                + "errorX,"
                + "errorY,"
                + "errorZ,"
                + "positionX,"
                + "positionY,"
                + "positionZ)"
                + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

        PreparedStatement dynamicStatement = conn.prepareStatement(dynamicQuery);

        dynamicStatement.setString(1, source.getUniqueId());


        /*
         * Java's interpretation of null and SQL interpretation of NULL are two
         * entirely different things. Unfortunately, if a Double is marked as
         * null in Java, SQL will not know what to do with it when attempting
         * to insert it in an row. It will throw a NullPointerException. The only
         * way around this to check every individual row field for being null. If
         * it is, a special setter must be called (built into PreparedStatement)
         * which will specifically set the column value to SQL NULL.
         */
        if (source.getThreatLevel() != null) {
            dynamicStatement.setInt(2, source.getThreatLevel());
        } else {
            dynamicStatement.setNull(2, 8);
        }

        if (source.getSourceLatitude() != null) {
            dynamicStatement.setDouble(3, source.getSourceLatitude());
        } else {
            dynamicStatement.setNull(3, 8);
        }

        if (source.getSourceLongitude() != null) {
            dynamicStatement.setDouble(4, source.getSourceLongitude());
        } else {
            dynamicStatement.setNull(4, 8);
        }

        if (source.getSourceAltitude() != null) {
            dynamicStatement.setDouble(5, source.getSourceAltitude());
        } else {
            dynamicStatement.setNull(5, 8);
        }

        if (source.getSpeedX() != null) {
            dynamicStatement.setDouble(6, source.getSpeedY());
        } else {
            dynamicStatement.setNull(6, 8);
        }

        if (source.getSpeedY() != null) {
            dynamicStatement.setDouble(7, source.getSpeedY());
        } else {
            dynamicStatement.setNull(7, 8);
        }

        if (source.getSpeedZ() != null) {
            dynamicStatement.setDouble(8, source.getSpeedZ());
        } else {
            dynamicStatement.setNull(8, 8);
        }

        if (source.getFuel() != null) {
            dynamicStatement.setDouble(9, source.getFuel());
        } else {
            dynamicStatement.setNull(9, 8);
        }

        if (source.getUpdateHertz() != null) {
            dynamicStatement.setDouble(10, source.getUpdateHertz());
        } else {
            dynamicStatement.setNull(10, 8);
        }

        if (source.getErrorX() != null) {
            dynamicStatement.setDouble(11, source.getErrorX());
        } else {
            dynamicStatement.setNull(11, 8);
        }

        if (source.getErrorY() != null) {
            dynamicStatement.setDouble(12, source.getErrorY());
        } else {
            dynamicStatement.setNull(12, 8);
        }

        if (source.getErrorZ() != null) {
            dynamicStatement.setDouble(13, source.getErrorZ());
        } else {
            dynamicStatement.setNull(13, 8);
        }

        if (source.getPositionLatitude() != null) {
            dynamicStatement.setDouble(14, source.getPositionLatitude());
        } else {
            dynamicStatement.setNull(14, 8);
        }

        if (source.getPositionLongitude() != null) {
            dynamicStatement.setDouble(15, source.getPositionLongitude());
        } else {
            dynamicStatement.setNull(15, 8);
        }

        if (source.getPositionAltitude() != null) {
            dynamicStatement.setDouble(16, source.getPositionAltitude());
        } else {
            dynamicStatement.setNull(16, 8);
        }


        /*
         * After execution of the statement, the connection should be closed
         * to free up resources in the databse.
         */
        dynamicStatement.execute();
        dynamicStatement.close();

    }

    /**
     * Given a Source this method will break up the information within the
     * module and add it to either the Dynamic or Static databases.
     *
     * If the Source is null, or missing a uniqueId the method is not executed
     * because a null Source or Source without a uniqueId is useless.
     *
     * @param source - Desired Source to add to the database.
     * @return - Nothing is Returned.
     * @throws SQLException - Throws an Exception if an error with the SQL
     * database occurs.
     */
    public void updateS2Builder(Source source) throws SQLException {

        //If the Source is null, or doesn't contain a uniqueId,
        //the information is worthless.
        if ((source == null) || (source.getUniqueId() == null)) {
            //throw exception.
        }

        //Before executing any statements, make sure that the uniqueId doesn't
        //already exist in the database.
        String staticExist = "SELECT * FROM S2staticInfo WHERE uniqueId = ?";
        PreparedStatement staticCheck = conn.prepareCall(staticExist);
        staticCheck.setString(1, source.getUniqueId());
        ResultSet queryResult = staticCheck.executeQuery();


        //Count the number of results, should be either 0 or 1.
        int counter = 0;
        while (queryResult.next()) {
            counter++;
        }


        /*
         * If the counter is 0, it means that this is the first time this
         * uniqueId is being inserted into the database. If the number is 1,
         * it means a row already exists containing the uniqueId.
         */
        if (counter < 1) {

            if (debugging) {
                System.out.println("database:updateS2Builder counter 0");
            }
            //Static Information
            String staticQuery = "INSERT INTO S2staticInfo("
                    + "uniqueId,"
                    + "trackType, "
                    + "trackPlatform,"
                    + "trackCategory)"
                    + "VALUES(?,?,?,?)";

            PreparedStatement staticStatement = conn.prepareStatement(staticQuery);

            staticStatement.setString(1, source.getUniqueId());
            staticStatement.setString(2, source.getClass().getName());
            staticStatement.setString(3, source.getTrackPlatform());
            staticStatement.setString(4, source.getTrackCategory());
            staticStatement.execute();
            staticStatement.close();
        } else {

            if (debugging) {
                System.out.println("database:S2updateBuilder counter 1");
            }
            //If the uniqueId already exists, update the information
            //accordingly rather then creating a new row with the
            //same uniqueId.
            String query = "UPDATE S2staticInfo"
                    + " SET trackType=?, "
                    + "trackPlatform=?, "
                    + "trackCategory=?";

            PreparedStatement staticUpdate = conn.prepareStatement(query);

            staticUpdate.setString(1, source.getClass().getName());
            staticUpdate.setString(2, source.getTrackPlatform());
            staticUpdate.setString(3, source.getTrackCategory());

            staticUpdate.execute();
            staticUpdate.close();
        }

        //Dynamic Information
        String dynamicQuery = "INSERT INTO S2dynamic("
                + "uniqueId,"
                + "threat,"
                + "latitude,"
                + "longitude,"
                + "altitude,"
                + "speedX,"
                + "speedY, "
                + "speedZ, "
                + "fuel,"
                + "hertz,"
                + "errorX,"
                + "errorY,"
                + "errorZ,"
                + "positionX,"
                + "positionY,"
                + "positionZ)"
                + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

        PreparedStatement dynamicStatement = conn.prepareStatement(dynamicQuery);

        dynamicStatement.setString(1, source.getUniqueId());


        /*
         * Java's interpretation of null and SQL interpretation of NULL are two
         * entirely different things. Unfortunately, if a Double is marked as
         * null in Java, SQL will not know what to do with it when attempting
         * to insert it in an row. It will throw a NullPointerException. The only
         * way around this to check every individual row field for being null. If
         * it is, a special setter must be called (built into PreparedStatement)
         * which will specifically set the column value to SQL NULL.
         */
        if (source.getThreatLevel() != null) {
            dynamicStatement.setInt(2, source.getThreatLevel());
        } else {
            dynamicStatement.setNull(2, 8);
        }

        if (source.getSourceLatitude() != null) {
            dynamicStatement.setDouble(3, source.getSourceLatitude());
        } else {
            dynamicStatement.setNull(3, 8);
        }

        if (source.getSourceLongitude() != null) {
            dynamicStatement.setDouble(4, source.getSourceLongitude());
        } else {
            dynamicStatement.setNull(4, 8);
        }

        if (source.getSourceAltitude() != null) {
            dynamicStatement.setDouble(5, source.getSourceAltitude());
        } else {
            dynamicStatement.setNull(5, 8);
        }

        if (source.getSpeedX() != null) {
            dynamicStatement.setDouble(6, source.getSpeedY());
        } else {
            dynamicStatement.setNull(6, 8);
        }

        if (source.getSpeedY() != null) {
            dynamicStatement.setDouble(7, source.getSpeedY());
        } else {
            dynamicStatement.setNull(7, 8);
        }

        if (source.getSpeedZ() != null) {
            dynamicStatement.setDouble(8, source.getSpeedZ());
        } else {
            dynamicStatement.setNull(8, 8);
        }

        if (source.getFuel() != null) {
            dynamicStatement.setDouble(9, source.getFuel());
        } else {
            dynamicStatement.setNull(9, 8);
        }

        if (source.getUpdateHertz() != null) {
            dynamicStatement.setDouble(10, source.getUpdateHertz());
        } else {
            dynamicStatement.setNull(10, 8);
        }

        if (source.getErrorX() != null) {
            dynamicStatement.setDouble(11, source.getErrorX());
        } else {
            dynamicStatement.setNull(11, 8);
        }

        if (source.getErrorY() != null) {
            dynamicStatement.setDouble(12, source.getErrorY());
        } else {
            dynamicStatement.setNull(12, 8);
        }

        if (source.getErrorZ() != null) {
            dynamicStatement.setDouble(13, source.getErrorZ());
        } else {
            dynamicStatement.setNull(13, 8);
        }

        if (source.getPositionLatitude() != null) {
            dynamicStatement.setDouble(14, source.getPositionLatitude());
        } else {
            dynamicStatement.setNull(14, 8);
        }

        if (source.getPositionLongitude() != null) {
            dynamicStatement.setDouble(15, source.getPositionLongitude());
        } else {
            dynamicStatement.setNull(15, 8);
        }

        if (source.getPositionAltitude() != null) {
            dynamicStatement.setDouble(16, source.getPositionAltitude());
        } else {
            dynamicStatement.setNull(16, 8);
        }


        /*
         * After execution of the statement, the connection should be closed
         * to free up resources in the databse.
         */
        dynamicStatement.execute();
        dynamicStatement.close();

    }

    /**
     * Given a Source this method will break up the information within the
     * module and add it to either the Dynamic or Static databases.
     *
     * If the Source is null, or missing a uniqueId the method is not executed
     * because a null Source or Source without a uniqueId is useless.
     *
     * @param source - Desired Source to add to the database.
     * @return - Nothing is Returned.
     * @throws SQLException - Throws an Exception if an error with the SQL
     * database occurs.
     */
    public void updateSystemBuilder(Source source) throws SQLException {

        //If the Source is null, or doesn't contain a uniqueId,
        //the information is worthless.
        if ((source == null) || (source.getUniqueId() == null)) {
            //throw exception.
        }

        //Before executing any statements, make sure that the uniqueId doesn't
        //already exist in the database.
        String staticExist = "SELECT * FROM systemStaticInfo WHERE uniqueId = ?";
        PreparedStatement staticCheck = conn.prepareCall(staticExist);
        staticCheck.setString(1, source.getUniqueId());
        ResultSet queryResult = staticCheck.executeQuery();


        //Count the number of results, should be either 0 or 1.
        int counter = 0;
        while (queryResult.next()) {
            counter++;
        }


        /*
         * If the counter is 0, it means that this is the first time this
         * uniqueId is being inserted into the database. If the number is 1,
         * it means a row already exists containing the uniqueId.
         */
        if (counter < 1) {

            if (debugging) {
                System.out.println("database:updateSystemBuilder counter 0");
            }
            //Static Information
            String staticQuery = "INSERT INTO systemStaticInfo("
                    + "uniqueId,"
                    + "trackType, "
                    + "trackPlatform,"
                    + "trackCategory)"
                    + "VALUES(?,?,?,?)";

            PreparedStatement staticStatement = conn.prepareStatement(staticQuery);

            staticStatement.setString(1, source.getUniqueId());
            staticStatement.setString(2, source.getClass().getName());
            staticStatement.setString(3, source.getTrackPlatform());
            staticStatement.setString(4, source.getTrackCategory());
            staticStatement.execute();
            staticStatement.close();

        } else {

            if (debugging) {
                System.out.println("database:updateSystemBuilder counter 1");
            }
            //If the uniqueId already exists, update the information
            //accordingly rather then creating a new row with the
            //same uniqueId.
            String query = "UPDATE systemStaticInfo"
                    + " SET trackType=?, "
                    + "trackPlatform=?, "
                    + "trackCategory=?";

            PreparedStatement staticUpdate = conn.prepareStatement(query);

            staticUpdate.setString(1, source.getClass().getName());
            staticUpdate.setString(2, source.getTrackPlatform());
            staticUpdate.setString(3, source.getTrackCategory());

            staticUpdate.execute();
            staticUpdate.close();
        }

        //Dynamic Information
        String dynamicQuery = "INSERT INTO systemDynamic("
                + "uniqueId,"
                + "threat,"
                + "latitude,"
                + "longitude,"
                + "altitude,"
                + "speedX,"
                + "speedY, "
                + "speedZ, "
                + "fuel,"
                + "hertz,"
                + "errorX,"
                + "errorY,"
                + "errorZ,"
                + "positionX,"
                + "positionY,"
                + "positionZ)"
                + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";


        PreparedStatement dynamicStatement = conn.prepareStatement(dynamicQuery);

        dynamicStatement.setString(1, source.getUniqueId());


        /*
         * Java's interpretation of null and SQL interpretation of NULL are two
         * entirely different things. Unfortunately, if a Double is marked as
         * null in Java, SQL will not know what to do with it when attempting
         * to insert it in an row. It will throw a NullPointerException. The only
         * way around this to check every individual row field for being null. If
         * it is, a special setter must be called (built into PreparedStatement)
         * which will specifically set the column value to SQL NULL.
         */
        if (source.getThreatLevel() != null) {
            dynamicStatement.setInt(2, source.getThreatLevel());
        } else {
            dynamicStatement.setNull(2, 8);
        }

        if (source.getSourceLatitude() != null) {
            dynamicStatement.setDouble(3, source.getSourceLatitude());
        } else {
            dynamicStatement.setNull(3, 8);
        }

        if (source.getSourceLongitude() != null) {
            dynamicStatement.setDouble(4, source.getSourceLongitude());
        } else {
            dynamicStatement.setNull(4, 8);
        }

        if (source.getSourceAltitude() != null) {
            dynamicStatement.setDouble(5, source.getSourceAltitude());
        } else {
            dynamicStatement.setNull(5, 8);
        }

        if (source.getSpeedX() != null) {
            dynamicStatement.setDouble(6, source.getSpeedY());
        } else {
            dynamicStatement.setNull(6, 8);
        }

        if (source.getSpeedY() != null) {
            dynamicStatement.setDouble(7, source.getSpeedY());
        } else {
            dynamicStatement.setNull(7, 8);
        }

        if (source.getSpeedZ() != null) {
            dynamicStatement.setDouble(8, source.getSpeedZ());
        } else {
            dynamicStatement.setNull(8, 8);
        }

        if (source.getFuel() != null) {
            dynamicStatement.setDouble(9, source.getFuel());
        } else {
            dynamicStatement.setNull(9, 8);
        }

        if (source.getUpdateHertz() != null) {
            dynamicStatement.setDouble(10, source.getUpdateHertz());
        } else {
            dynamicStatement.setNull(10, 8);
        }

        if (source.getErrorX() != null) {
            dynamicStatement.setDouble(11, source.getErrorX());
        } else {
            dynamicStatement.setNull(11, 8);
        }

        if (source.getErrorY() != null) {
            dynamicStatement.setDouble(12, source.getErrorY());
        } else {
            dynamicStatement.setNull(12, 8);
        }

        if (source.getErrorZ() != null) {
            dynamicStatement.setDouble(13, source.getErrorZ());
        } else {
            dynamicStatement.setNull(13, 8);
        }

        if (source.getPositionLatitude() != null) {
            dynamicStatement.setDouble(14, source.getPositionLatitude());
        } else {
            dynamicStatement.setNull(14, 8);
        }

        if (source.getPositionLongitude() != null) {
            dynamicStatement.setDouble(15, source.getPositionLongitude());
        } else {
            dynamicStatement.setNull(15, 8);
        }

        if (source.getPositionAltitude() != null) {
            dynamicStatement.setDouble(16, source.getPositionAltitude());
        } else {
            dynamicStatement.setNull(16, 8);
        }


        /*
         * After execution of the statement, the connection should be closed
         * to free up resources in the databse.
         */
        dynamicStatement.execute();
        dynamicStatement.close();

    }

    private Source getStaticInformation(String uniqueId) throws SQLException {

        String staticQuery;

        staticQuery = "SELECT * FROM staticInfo WHERE uniqueId = (?)";

        PreparedStatement staticStatement = conn.prepareCall(staticQuery);
        staticStatement.setString(1, uniqueId);
        ResultSet staticResults = staticStatement.executeQuery();

        /**
         * Create a new Source object and add the Static information to it.
         * This will be used while iterating through the dynamic information
         * later. It is more efficent to create a Object containing the Static
         * information rather than iterating through a ResultSet X amount of
         * times.
         */
        Source staticSource = new Source(uniqueId);

        //Source staticSource = new Source();
        while (staticResults.next()) {
            //Save the Static Information in a source.
            staticSource.setUniqueId(uniqueId);
            staticSource.setTrackPlatform(staticResults.getString("trackPlatform"));
            staticSource.setTrackCategory(staticResults.getString("trackCategory"));

        }

        return staticSource;
    }

    private Timestamp getFirstTimeEntryInDatabase(String uniqueId) throws SQLException {

        String query = "SELECT dateCreated FROM dynamic WHERE uniqueId = ?";

        PreparedStatement statement = conn.prepareStatement(query);
        statement.setString(1, uniqueId);
        ResultSet result = statement.executeQuery();


        //iterate through the dynamic results, create a new source object
        //and all it to the Source array which will be returned to the
        //requesting module.
        while (result.next()) {

            return result.getTimestamp("dateCreated");
        }

        return null;


    }

    /**
     * This module will return a single source matching a desired time. This module will pad
     * the desired time request with +/- 2 seconds to increase the probability that a result
     * will be sucessfully fetched.
     *
     * This module will take the query results, and return the first Source object generated
     * by the ResultSet. If no information is available within that time frame, null will
     * be returned.
     *
     * @param uniqueId - The UniqueId of the desired Source.
     * @param desiredTime - The desired time for a source to be returned.
     * @return A single Source matching the desiredTime, or null if no Sources exist in the
     * database matching the desired time.
     * @throws SQLException Throws an exception if an errors occurs with SQL. 
     */
    public Source queryBuilder(String uniqueId, long desiredTime) throws SQLException {


        //TODO, fix other query builder method.


        //Gets the creation date of the first uniqueId
        Timestamp firstEntry = getFirstTimeEntryInDatabase(uniqueId);

        if (firstEntry == null) {
            //throw error, ID doesnt exist. 
        }

        //Grabs the Static Information.
        Source staticSource = getStaticInformation(uniqueId);

        //Given the curent time, create a +/- 2 second range to query the database from. 
        Timestamp startingTimeStamp = new Timestamp(desiredTime + 2000);
        Timestamp endingTimeStamp = new Timestamp(desiredTime - 2000);


        if (startingTimeStamp.before(firstEntry)) {
            startingTimeStamp = firstEntry;
        }
        //String dynamicQuery = "SELECT * FROM dynamic WHERE (dateCreated BETWEEN ? AND ?) AND (uniqueId = ?)";
        String dynamicQuery = "SELECT * FROM dynamic WHERE (dateCreated BETWEEN ? AND ?) AND (uniqueId = ?)";
        PreparedStatement statement = conn.prepareStatement(dynamicQuery);
        statement.setTimestamp(1, endingTimeStamp);
        statement.setTimestamp(2, startingTimeStamp);
        statement.setString(3, uniqueId);
        ResultSet dynamicResults = statement.executeQuery();


        //iterate through the dynamic results, create a new source object
        //and all it to the Source array which will be returned to the
        //requesting module.
        while (dynamicResults.next()) {

            Source temp = new Source(
                    uniqueId,
                    staticSource.getTrackPlatform(),
                    staticSource.getTrackCategory(),
                    dynamicResults.getInt("threat"),
                    dynamicResults.getDouble("speedX"),
                    dynamicResults.getDouble("speedY"),
                    dynamicResults.getDouble("latitude"),
                    dynamicResults.getDouble("longitude"),
                    dynamicResults.getDouble("altitude"),
                    dynamicResults.getDouble("fuel"),
                    dynamicResults.getDouble("errorX"),
                    dynamicResults.getDouble("errorY"),
                    dynamicResults.getDouble("hertz"),
                    dynamicResults.getDouble("positionX"),
                    dynamicResults.getDouble("positionY"),
                    dynamicResults.getDouble("errorZ"),
                    dynamicResults.getDouble("positionZ"),
                    dynamicResults.getDouble("speedZ"));

            return temp;
        }

        //If no results were returned, return null
        return null;
    }

    /**
     * The method generates an ArrayList of Sources to return to a requesting module.
     * This method queries the database fetching all information matching a specified
     * uniqueId, sourceType (Air, Naval, Ground), and a time range. The information
     * that is returned is converted into a Source object and added to an ArrayList
     * which is returned to the user after all results returned are added to the List.
     *
     * @param sourceType - Type of Source - AirSource, GroundSource, or NavalSource.
     * @param uniqueId - The UniqueId of the Information needed.
     * @param fromTime - The earliest time of the desired information.
     * @return an ArrayList of Sources generated from the queried information in
     * the database.
     * @throws SQLException - Throws an exception if the connection to the database
     * fails.
     */
    public ArrayList<Source> queryBuilder(String sourceType,
            String uniqueId, long fromTime) throws SQLException {


        //Gets the creation date of the first uniqueId
        Timestamp firstEntry = getFirstTimeEntryInDatabase(uniqueId);

        if (firstEntry == null) {
            //throw error, ID doesnt exist.
        }

        //Fetches the Static Information corresponding with the
        Source staticSource = getStaticInformation(uniqueId);

        /**
         * Fetch the Dynamic Information.
         */
        Timestamp fromTimeStamp = new Timestamp(fromTime);
        Timestamp currentTimeStamp = new Timestamp(System.currentTimeMillis());

        if (fromTimeStamp.before(firstEntry)) {
            fromTimeStamp = firstEntry;
        }

        String dynamicQuery = "SELECT * FROM dynamic WHERE dateCreated BETWEEN ? AND ? AND uniqueId = ?";
        PreparedStatement statement = conn.prepareStatement(dynamicQuery);
        statement.setTimestamp(1, currentTimeStamp);
        statement.setTimestamp(2, fromTimeStamp);
        statement.setString(3, uniqueId);
        ResultSet dynamicResults = statement.executeQuery();


        ArrayList<Source> resultArray = new ArrayList<Source>();

        //iterate through the dynamic results, create a new source object
        //and all it to the Source array which will be returned to the
        //requesting module.
        while (dynamicResults.next()) {

            Source temp = new Source(
                    uniqueId,
                    staticSource.getTrackPlatform(),
                    staticSource.getTrackCategory(),
                    dynamicResults.getInt("threat"),
                    dynamicResults.getDouble("speedX"),
                    dynamicResults.getDouble("speedY"),
                    dynamicResults.getDouble("latitude"),
                    dynamicResults.getDouble("longitude"),
                    dynamicResults.getDouble("altitude"),
                    dynamicResults.getDouble("fuel"),
                    dynamicResults.getDouble("errorX"),
                    dynamicResults.getDouble("errorY"),
                    dynamicResults.getDouble("hertz"),
                    dynamicResults.getDouble("positionX"),
                    dynamicResults.getDouble("positionY"),
                    dynamicResults.getDouble("errorZ"),
                    dynamicResults.getDouble("positionZ"),
                    dynamicResults.getDouble("speedZ"));

            resultArray.add(temp);

        }
        return resultArray;
    }
}
